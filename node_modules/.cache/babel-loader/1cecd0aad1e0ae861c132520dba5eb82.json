{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ContainerState} ContainerState\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { asciiDigit, markdownSpace } from 'micromark-util-character';\nimport { blankLine } from './blank-line.js';\nimport { thematicBreak } from './thematic-break.js';\n\n/** @type {Construct} */\nexport const list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n};\n\n/** @type {Construct} */\nconst listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n};\n\n/** @type {Construct} */\nconst indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n};\n\n// To do: `markdown-rs` parses list items on their own and later stitches them\n// together.\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  let initialSize = tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let size = 0;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    const kind = self.containerState.type || (code === 42 || code === 43 || code === 45 ? 'listUnordered' : 'listOrdered');\n    if (kind === 'listUnordered' ? !self.containerState.marker || code === self.containerState.marker : asciiDigit(code)) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind;\n        effects.enter(kind, {\n          _container: true\n        });\n      }\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix');\n        return code === 42 || code === 45 ? effects.check(thematicBreak, nok, atMarker)(code) : atMarker(code);\n      }\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix');\n        effects.enter('listItemValue');\n        return inside(code);\n      }\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code);\n      return inside;\n    }\n    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code === self.containerState.marker : code === 41 || code === 46)) {\n      effects.exit('listItemValue');\n      return atMarker(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * @type {State}\n   **/\n  function atMarker(code) {\n    effects.enter('listItemMarker');\n    effects.consume(code);\n    effects.exit('listItemMarker');\n    self.containerState.marker = self.containerState.marker || code;\n    return effects.check(blankLine,\n    // Can’t be empty when interrupting.\n    self.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));\n  }\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true;\n    initialSize++;\n    return endOfPrefix(code);\n  }\n\n  /** @type {State} */\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace');\n      effects.consume(code);\n      effects.exit('listItemPrefixWhitespace');\n      return endOfPrefix;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function endOfPrefix(code) {\n    self.containerState.size = initialSize + self.sliceSerialize(effects.exit('listItemPrefix'), true).length;\n    return ok(code);\n  }\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this;\n  self.containerState._closeFlow = undefined;\n  return effects.check(blankLine, onBlank, notBlank);\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine;\n\n    // We have a blank line.\n    // Still, try to consume at most the items size.\n    return factorySpace(effects, ok, 'listItemIndent', self.containerState.size + 1)(code);\n  }\n\n  /** @type {State} */\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = undefined;\n      self.containerState.initialBlankLine = undefined;\n      return notInCurrentItem(code);\n    }\n    self.containerState.furtherBlankLines = undefined;\n    self.containerState.initialBlankLine = undefined;\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);\n  }\n\n  /** @type {State} */\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true;\n    // As we’re closing flow, we’re no longer interrupting.\n    self.interrupt = undefined;\n    // Always populated by defaults.\n\n    return factorySpace(effects, effects.attempt(list, ok, nok), 'linePrefix', self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4)(code);\n  }\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this;\n  return factorySpace(effects, afterPrefix, 'listItemIndent', self.containerState.size + 1);\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'listItemIndent' && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok(code) : nok(code);\n  }\n}\n\n/**\n * @type {Exiter}\n * @this {TokenizeContext}\n */\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type);\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this;\n\n  // Always populated by defaults.\n\n  return factorySpace(effects, afterPrefix, 'listItemPrefixWhitespace', self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4 + 1);\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return !markdownSpace(code) && tail && tail[1].type === 'listItemPrefixWhitespace' ? ok(code) : nok(code);\n  }\n}","map":{"version":3,"names":["factorySpace","asciiDigit","markdownSpace","blankLine","thematicBreak","list","name","tokenize","tokenizeListStart","continuation","tokenizeListContinuation","exit","tokenizeListEnd","listItemPrefixWhitespaceConstruct","tokenizeListItemPrefixWhitespace","partial","indentConstruct","tokenizeIndent","effects","ok","nok","self","tail","events","length","initialSize","type","sliceSerialize","size","start","code","kind","containerState","marker","enter","_container","check","atMarker","interrupt","inside","consume","onBlank","attempt","endOfPrefix","otherPrefix","initialBlankLine","_closeFlow","undefined","notBlank","furtherBlankLines","notInCurrentItem","parser","constructs","disable","null","includes","afterPrefix"],"sources":["/Users/iClon/Desktop/sergio/dev-portfolio/node_modules/micromark-core-commonmark/lib/list.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ContainerState} ContainerState\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {asciiDigit, markdownSpace} from 'micromark-util-character'\nimport {blankLine} from './blank-line.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/** @type {Construct} */\nexport const list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n}\n\n/** @type {Construct} */\nconst listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n}\n\n/** @type {Construct} */\nconst indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n\n// To do: `markdown-rs` parses list items on their own and later stitches them\n// together.\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  let initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let size = 0\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    const kind =\n      self.containerState.type ||\n      (code === 42 || code === 43 || code === 45\n        ? 'listUnordered'\n        : 'listOrdered')\n    if (\n      kind === 'listUnordered'\n        ? !self.containerState.marker || code === self.containerState.marker\n        : asciiDigit(code)\n    ) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind\n        effects.enter(kind, {\n          _container: true\n        })\n      }\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix')\n        return code === 42 || code === 45\n          ? effects.check(thematicBreak, nok, atMarker)(code)\n          : atMarker(code)\n      }\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix')\n        effects.enter('listItemValue')\n        return inside(code)\n      }\n    }\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code)\n      return inside\n    }\n    if (\n      (!self.interrupt || size < 2) &&\n      (self.containerState.marker\n        ? code === self.containerState.marker\n        : code === 41 || code === 46)\n    ) {\n      effects.exit('listItemValue')\n      return atMarker(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * @type {State}\n   **/\n  function atMarker(code) {\n    effects.enter('listItemMarker')\n    effects.consume(code)\n    effects.exit('listItemMarker')\n    self.containerState.marker = self.containerState.marker || code\n    return effects.check(\n      blankLine,\n      // Can’t be empty when interrupting.\n      self.interrupt ? nok : onBlank,\n      effects.attempt(\n        listItemPrefixWhitespaceConstruct,\n        endOfPrefix,\n        otherPrefix\n      )\n    )\n  }\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true\n    initialSize++\n    return endOfPrefix(code)\n  }\n\n  /** @type {State} */\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace')\n      effects.consume(code)\n      effects.exit('listItemPrefixWhitespace')\n      return endOfPrefix\n    }\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function endOfPrefix(code) {\n    self.containerState.size =\n      initialSize +\n      self.sliceSerialize(effects.exit('listItemPrefix'), true).length\n    return ok(code)\n  }\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this\n  self.containerState._closeFlow = undefined\n  return effects.check(blankLine, onBlank, notBlank)\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.furtherBlankLines =\n      self.containerState.furtherBlankLines ||\n      self.containerState.initialBlankLine\n\n    // We have a blank line.\n    // Still, try to consume at most the items size.\n    return factorySpace(\n      effects,\n      ok,\n      'listItemIndent',\n      self.containerState.size + 1\n    )(code)\n  }\n\n  /** @type {State} */\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = undefined\n      self.containerState.initialBlankLine = undefined\n      return notInCurrentItem(code)\n    }\n    self.containerState.furtherBlankLines = undefined\n    self.containerState.initialBlankLine = undefined\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)\n  }\n\n  /** @type {State} */\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true\n    // As we’re closing flow, we’re no longer interrupting.\n    self.interrupt = undefined\n    // Always populated by defaults.\n\n    return factorySpace(\n      effects,\n      effects.attempt(list, ok, nok),\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )(code)\n  }\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemIndent',\n    self.containerState.size + 1\n  )\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'listItemIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === self.containerState.size\n      ? ok(code)\n      : nok(code)\n  }\n}\n\n/**\n * @type {Exiter}\n * @this {TokenizeContext}\n */\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type)\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this\n\n  // Always populated by defaults.\n\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemPrefixWhitespace',\n    self.parser.constructs.disable.null.includes('codeIndented')\n      ? undefined\n      : 4 + 1\n  )\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return !markdownSpace(code) &&\n      tail &&\n      tail[1].type === 'listItemPrefixWhitespace'\n      ? ok(code)\n      : nok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}