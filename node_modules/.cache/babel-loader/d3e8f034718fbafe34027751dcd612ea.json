{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { factoryDestination } from 'micromark-factory-destination';\nimport { factoryLabel } from 'micromark-factory-label';\nimport { factoryTitle } from 'micromark-factory-title';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { push, splice } from 'micromark-util-chunked';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { resolveAll } from 'micromark-util-resolve-all';\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n};\n\n/** @type {Construct} */\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n};\n/** @type {Construct} */\nconst referenceFullConstruct = {\n  tokenize: tokenizeReferenceFull\n};\n/** @type {Construct} */\nconst referenceCollapsedConstruct = {\n  tokenize: tokenizeReferenceCollapsed\n};\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1;\n  while (++index < events.length) {\n    const token = events[index][1];\n    if (token.type === 'labelImage' || token.type === 'labelLink' || token.type === 'labelEnd') {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2);\n      token.type = 'data';\n      index++;\n    }\n  }\n  return events;\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length;\n  let offset = 0;\n  /** @type {Token} */\n  let token;\n  /** @type {number | undefined} */\n  let open;\n  /** @type {number | undefined} */\n  let close;\n  /** @type {Array<Event>} */\n  let media;\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1];\n    if (open) {\n      // If we see another link, or inactive link label, weâ€™ve been here before.\n      if (token.type === 'link' || token.type === 'labelLink' && token._inactive) {\n        break;\n      }\n\n      // Mark other link openings as inactive, as we canâ€™t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true;\n      }\n    } else if (close) {\n      if (events[index][0] === 'enter' && (token.type === 'labelImage' || token.type === 'labelLink') && !token._balanced) {\n        open = index;\n        if (token.type !== 'labelLink') {\n          offset = 2;\n          break;\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index;\n    }\n  }\n  const group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n  const label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  };\n  const text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  };\n  media = [['enter', group, context], ['enter', label, context]];\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3));\n\n  // Text open.\n  media = push(media, [['enter', text, context]]);\n\n  // Always populated by defaults.\n\n  // Between.\n  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));\n\n  // Text close, marker close, label close.\n  media = push(media, [['exit', text, context], events[close - 2], events[close - 1], ['exit', label, context]]);\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1));\n\n  // Media close.\n  media = push(media, [['exit', group, context]]);\n  splice(events, open, events.length, media);\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  /** @type {Token} */\n  let labelStart;\n  /** @type {boolean} */\n  let defined;\n\n  // Find an opening.\n  while (index--) {\n    if ((self.events[index][1].type === 'labelImage' || self.events[index][1].type === 'labelLink') && !self.events[index][1]._balanced) {\n      labelStart = self.events[index][1];\n      break;\n    }\n  }\n  return start;\n\n  /**\n   * Start of label end.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // If there is not an okay opening.\n    if (!labelStart) {\n      return nok(code);\n    }\n\n    // If the corresponding label (link) start is marked as inactive,\n    // it means weâ€™d be wrapping a link, like this:\n    //\n    // ```markdown\n    // > | a [b [c](d) e](f) g.\n    //                  ^\n    // ```\n    //\n    // We canâ€™t have that, so itâ€™s just balanced brackets.\n    if (labelStart._inactive) {\n      return labelEndNok(code);\n    }\n    defined = self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    })));\n    effects.enter('labelEnd');\n    effects.enter('labelMarker');\n    effects.consume(code);\n    effects.exit('labelMarker');\n    effects.exit('labelEnd');\n    return after;\n  }\n\n  /**\n   * After `]`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\n    // an extension.\n\n    // Resource (`[asd](fgh)`)?\n    if (code === 40) {\n      return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code);\n    }\n\n    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n    if (code === 91) {\n      return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code);\n    }\n\n    // Shortcut (`[asd]`) reference?\n    return defined ? labelEndOk(code) : labelEndNok(code);\n  }\n\n  /**\n   * After `]`, at `[`, but not at a full reference.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] b\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceNotFull(code) {\n    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code);\n  }\n\n  /**\n   * Done, we found something.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *           ^\n   * > | [a][b] c\n   *           ^\n   * > | [a][] b\n   *          ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndOk(code) {\n    // Note: `markdown-rs` does a bunch of stuff here.\n    return ok(code);\n  }\n\n  /**\n   * Done, itâ€™s nothing.\n   *\n   * There was an okay opening, but we didnâ€™t match anything.\n   *\n   * ```markdown\n   * > | [a](b c\n   *        ^\n   * > | [a][b c\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndNok(code) {\n    labelStart._balanced = true;\n    return nok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeResource(effects, ok, nok) {\n  return resourceStart;\n\n  /**\n   * At a resource.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceStart(code) {\n    effects.enter('resource');\n    effects.enter('resourceMarker');\n    effects.consume(code);\n    effects.exit('resourceMarker');\n    return resourceBefore;\n  }\n\n  /**\n   * In resource, after `(`, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceOpen)(code) : resourceOpen(code);\n  }\n\n  /**\n   * In resource, after optional whitespace, at `)` or a destination.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceOpen(code) {\n    if (code === 41) {\n      return resourceEnd(code);\n    }\n    return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, 'resourceDestination', 'resourceDestinationLiteral', 'resourceDestinationLiteralMarker', 'resourceDestinationRaw', 'resourceDestinationString', 32)(code);\n  }\n\n  /**\n   * In resource, after destination, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceBetween)(code) : resourceEnd(code);\n  }\n\n  /**\n   * At invalid destination.\n   *\n   * ```markdown\n   * > | [a](<<) b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationMissing(code) {\n    return nok(code);\n  }\n\n  /**\n   * In resource, after destination and whitespace, at `(` or title.\n   *\n   * ```markdown\n   * > | [a](b ) c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBetween(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(effects, resourceTitleAfter, nok, 'resourceTitle', 'resourceTitleMarker', 'resourceTitleString')(code);\n    }\n    return resourceEnd(code);\n  }\n\n  /**\n   * In resource, after title, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b \"c\") d\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceEnd)(code) : resourceEnd(code);\n  }\n\n  /**\n   * In resource, at `)`.\n   *\n   * ```markdown\n   * > | [a](b) d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceEnd(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker');\n      effects.consume(code);\n      effects.exit('resourceMarker');\n      effects.exit('resource');\n      return ok;\n    }\n    return nok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceFull(effects, ok, nok) {\n  const self = this;\n  return referenceFull;\n\n  /**\n   * In a reference (full), at the `[`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFull(code) {\n    return factoryLabel.call(self, effects, referenceFullAfter, referenceFullMissing, 'reference', 'referenceMarker', 'referenceString')(code);\n  }\n\n  /**\n   * In a reference (full), after `]`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\n  }\n\n  /**\n   * In reference (full) that was missing.\n   *\n   * ```markdown\n   * > | [a][b d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullMissing(code) {\n    return nok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\n  return referenceCollapsedStart;\n\n  /**\n   * In reference (collapsed), at `[`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceCollapsedStart(code) {\n    // We only attempt a collapsed label if thereâ€™s a `[`.\n\n    effects.enter('reference');\n    effects.enter('referenceMarker');\n    effects.consume(code);\n    effects.exit('referenceMarker');\n    return referenceCollapsedOpen;\n  }\n\n  /**\n   * In reference (collapsed), at `]`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *         ^\n   * ```\n   *\n   *  @type {State}\n   */\n  function referenceCollapsedOpen(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker');\n      effects.consume(code);\n      effects.exit('referenceMarker');\n      effects.exit('reference');\n      return ok;\n    }\n    return nok(code);\n  }\n}","map":{"version":3,"names":["factoryDestination","factoryLabel","factoryTitle","factoryWhitespace","markdownLineEndingOrSpace","push","splice","normalizeIdentifier","resolveAll","labelEnd","name","tokenize","tokenizeLabelEnd","resolveTo","resolveToLabelEnd","resolveAllLabelEnd","resourceConstruct","tokenizeResource","referenceFullConstruct","tokenizeReferenceFull","referenceCollapsedConstruct","tokenizeReferenceCollapsed","events","index","length","token","type","context","offset","open","close","media","_inactive","_balanced","group","start","Object","assign","end","label","text","slice","parser","constructs","insideSpan","null","effects","ok","nok","self","labelStart","defined","code","labelEndNok","includes","sliceSerialize","now","enter","consume","exit","after","attempt","labelEndOk","referenceNotFull","resourceStart","resourceBefore","resourceOpen","resourceEnd","resourceDestinationAfter","resourceDestinationMissing","resourceBetween","resourceTitleAfter","referenceFull","call","referenceFullAfter","referenceFullMissing","referenceCollapsedStart","referenceCollapsedOpen"],"sources":["/Users/iClon/Desktop/sergio/dev-portfolio/node_modules/micromark-core-commonmark/lib/label-end.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n\n/** @type {Construct} */\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n}\n/** @type {Construct} */\nconst referenceFullConstruct = {\n  tokenize: tokenizeReferenceFull\n}\n/** @type {Construct} */\nconst referenceCollapsedConstruct = {\n  tokenize: tokenizeReferenceCollapsed\n}\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  while (++index < events.length) {\n    const token = events[index][1]\n    if (\n      token.type === 'labelImage' ||\n      token.type === 'labelLink' ||\n      token.type === 'labelEnd'\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)\n      token.type = 'data'\n      index++\n    }\n  }\n  return events\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n  let token\n  /** @type {number | undefined} */\n  let open\n  /** @type {number | undefined} */\n  let close\n  /** @type {Array<Event>} */\n  let media\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1]\n    if (open) {\n      // If we see another link, or inactive link label, weâ€™ve been here before.\n      if (\n        token.type === 'link' ||\n        (token.type === 'labelLink' && token._inactive)\n      ) {\n        break\n      }\n\n      // Mark other link openings as inactive, as we canâ€™t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === 'labelImage' || token.type === 'labelLink') &&\n        !token._balanced\n      ) {\n        open = index\n        if (token.type !== 'labelLink') {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index\n    }\n  }\n  const group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  const label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n  const text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ]\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3))\n\n  // Text open.\n  media = push(media, [['enter', text, context]])\n\n  // Always populated by defaults.\n\n  // Between.\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  )\n\n  // Text close, marker close, label close.\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ])\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1))\n\n  // Media close.\n  media = push(media, [['exit', group, context]])\n  splice(events, open, events.length, media)\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n  let labelStart\n  /** @type {boolean} */\n  let defined\n\n  // Find an opening.\n  while (index--) {\n    if (\n      (self.events[index][1].type === 'labelImage' ||\n        self.events[index][1].type === 'labelLink') &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n  return start\n\n  /**\n   * Start of label end.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // If there is not an okay opening.\n    if (!labelStart) {\n      return nok(code)\n    }\n\n    // If the corresponding label (link) start is marked as inactive,\n    // it means weâ€™d be wrapping a link, like this:\n    //\n    // ```markdown\n    // > | a [b [c](d) e](f) g.\n    //                  ^\n    // ```\n    //\n    // We canâ€™t have that, so itâ€™s just balanced brackets.\n    if (labelStart._inactive) {\n      return labelEndNok(code)\n    }\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({\n          start: labelStart.end,\n          end: self.now()\n        })\n      )\n    )\n    effects.enter('labelEnd')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelEnd')\n    return after\n  }\n\n  /**\n   * After `]`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\n    // an extension.\n\n    // Resource (`[asd](fgh)`)?\n    if (code === 40) {\n      return effects.attempt(\n        resourceConstruct,\n        labelEndOk,\n        defined ? labelEndOk : labelEndNok\n      )(code)\n    }\n\n    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n    if (code === 91) {\n      return effects.attempt(\n        referenceFullConstruct,\n        labelEndOk,\n        defined ? referenceNotFull : labelEndNok\n      )(code)\n    }\n\n    // Shortcut (`[asd]`) reference?\n    return defined ? labelEndOk(code) : labelEndNok(code)\n  }\n\n  /**\n   * After `]`, at `[`, but not at a full reference.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] b\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceNotFull(code) {\n    return effects.attempt(\n      referenceCollapsedConstruct,\n      labelEndOk,\n      labelEndNok\n    )(code)\n  }\n\n  /**\n   * Done, we found something.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *           ^\n   * > | [a][b] c\n   *           ^\n   * > | [a][] b\n   *          ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndOk(code) {\n    // Note: `markdown-rs` does a bunch of stuff here.\n    return ok(code)\n  }\n\n  /**\n   * Done, itâ€™s nothing.\n   *\n   * There was an okay opening, but we didnâ€™t match anything.\n   *\n   * ```markdown\n   * > | [a](b c\n   *        ^\n   * > | [a][b c\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndNok(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeResource(effects, ok, nok) {\n  return resourceStart\n\n  /**\n   * At a resource.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceStart(code) {\n    effects.enter('resource')\n    effects.enter('resourceMarker')\n    effects.consume(code)\n    effects.exit('resourceMarker')\n    return resourceBefore\n  }\n\n  /**\n   * In resource, after `(`, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceOpen)(code)\n      : resourceOpen(code)\n  }\n\n  /**\n   * In resource, after optional whitespace, at `)` or a destination.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceOpen(code) {\n    if (code === 41) {\n      return resourceEnd(code)\n    }\n    return factoryDestination(\n      effects,\n      resourceDestinationAfter,\n      resourceDestinationMissing,\n      'resourceDestination',\n      'resourceDestinationLiteral',\n      'resourceDestinationLiteralMarker',\n      'resourceDestinationRaw',\n      'resourceDestinationString',\n      32\n    )(code)\n  }\n\n  /**\n   * In resource, after destination, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceBetween)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * At invalid destination.\n   *\n   * ```markdown\n   * > | [a](<<) b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationMissing(code) {\n    return nok(code)\n  }\n\n  /**\n   * In resource, after destination and whitespace, at `(` or title.\n   *\n   * ```markdown\n   * > | [a](b ) c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBetween(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        resourceTitleAfter,\n        nok,\n        'resourceTitle',\n        'resourceTitleMarker',\n        'resourceTitleString'\n      )(code)\n    }\n    return resourceEnd(code)\n  }\n\n  /**\n   * In resource, after title, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b \"c\") d\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceEnd)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * In resource, at `)`.\n   *\n   * ```markdown\n   * > | [a](b) d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceEnd(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker')\n      effects.consume(code)\n      effects.exit('resourceMarker')\n      effects.exit('resource')\n      return ok\n    }\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceFull(effects, ok, nok) {\n  const self = this\n  return referenceFull\n\n  /**\n   * In a reference (full), at the `[`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFull(code) {\n    return factoryLabel.call(\n      self,\n      effects,\n      referenceFullAfter,\n      referenceFullMissing,\n      'reference',\n      'referenceMarker',\n      'referenceString'\n    )(code)\n  }\n\n  /**\n   * In a reference (full), after `]`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n\n  /**\n   * In reference (full) that was missing.\n   *\n   * ```markdown\n   * > | [a][b d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullMissing(code) {\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\n  return referenceCollapsedStart\n\n  /**\n   * In reference (collapsed), at `[`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceCollapsedStart(code) {\n    // We only attempt a collapsed label if thereâ€™s a `[`.\n\n    effects.enter('reference')\n    effects.enter('referenceMarker')\n    effects.consume(code)\n    effects.exit('referenceMarker')\n    return referenceCollapsedOpen\n  }\n\n  /**\n   * In reference (collapsed), at `]`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *         ^\n   * ```\n   *\n   *  @type {State}\n   */\n  function referenceCollapsedOpen(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker')\n      effects.consume(code)\n      effects.exit('referenceMarker')\n      effects.exit('reference')\n      return ok\n    }\n    return nok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}