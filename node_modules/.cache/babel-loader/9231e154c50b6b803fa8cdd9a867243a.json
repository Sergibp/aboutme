{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { splice } from 'micromark-util-chunked';\n/** @type {Construct} */\nexport const headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n};\n\n/** @type {Resolver} */\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2;\n  let contentStart = 3;\n  /** @type {Token} */\n  let content;\n  /** @type {Token} */\n  let text;\n\n  // Prefix whitespace, part of the opening.\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2;\n  }\n\n  // Suffix whitespace, part of the closing.\n  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === 'whitespace') {\n    contentEnd -= 2;\n  }\n  if (events[contentEnd][1].type === 'atxHeadingSequence' && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === 'whitespace')) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;\n  }\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    };\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      contentType: 'text'\n    };\n    splice(events, contentStart, contentEnd - contentStart + 1, [['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]]);\n  }\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  let size = 0;\n  return start;\n\n  /**\n   * Start of a heading (atx).\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    effects.enter('atxHeading');\n    return before(code);\n  }\n\n  /**\n   * After optional whitespace, at `#`.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter('atxHeadingSequence');\n    return sequenceOpen(code);\n  }\n\n  /**\n   * In opening sequence.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code);\n      return sequenceOpen;\n    }\n\n    // Always at least one `#`.\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingSequence');\n      return atBreak(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * After something, before something else.\n   *\n   * ```markdown\n   * > | ## aa\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence');\n      return sequenceFurther(code);\n    }\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('atxHeading');\n      // To do: interrupt like `markdown-rs`.\n      // // Feel free to interrupt.\n      // tokenizer.interrupt = false\n      return ok(code);\n    }\n    if (markdownSpace(code)) {\n      return factorySpace(effects, atBreak, 'whitespace')(code);\n    }\n\n    // To do: generate `data` tokens, add the `text` token later.\n    // Needs edit map, see: `markdown.rs`.\n    effects.enter('atxHeadingText');\n    return data(code);\n  }\n\n  /**\n   * In further sequence (after whitespace).\n   *\n   * Could be normal “visible” hashes in the heading or a final sequence.\n   *\n   * ```markdown\n   * > | ## aa ##\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceFurther(code) {\n    if (code === 35) {\n      effects.consume(code);\n      return sequenceFurther;\n    }\n    effects.exit('atxHeadingSequence');\n    return atBreak(code);\n  }\n\n  /**\n   * In text.\n   *\n   * ```markdown\n   * > | ## aa\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function data(code) {\n    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingText');\n      return atBreak(code);\n    }\n    effects.consume(code);\n    return data;\n  }\n}","map":{"version":3,"names":["factorySpace","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","splice","headingAtx","name","tokenize","tokenizeHeadingAtx","resolve","resolveHeadingAtx","events","context","contentEnd","length","contentStart","content","text","type","start","end","contentType","effects","ok","nok","size","code","enter","before","sequenceOpen","consume","exit","atBreak","sequenceFurther","data"],"sources":["/Users/iClon/Documents/GitHub/aboutme/node_modules/micromark-core-commonmark/lib/heading-atx.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\n/** @type {Construct} */\nexport const headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n}\n\n/** @type {Resolver} */\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2\n  let contentStart = 3\n  /** @type {Token} */\n  let content\n  /** @type {Token} */\n  let text\n\n  // Prefix whitespace, part of the opening.\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2\n  }\n\n  // Suffix whitespace, part of the closing.\n  if (\n    contentEnd - 2 > contentStart &&\n    events[contentEnd][1].type === 'whitespace'\n  ) {\n    contentEnd -= 2\n  }\n  if (\n    events[contentEnd][1].type === 'atxHeadingSequence' &&\n    (contentStart === contentEnd - 1 ||\n      (contentEnd - 4 > contentStart &&\n        events[contentEnd - 2][1].type === 'whitespace'))\n  ) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4\n  }\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    }\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      contentType: 'text'\n    }\n    splice(events, contentStart, contentEnd - contentStart + 1, [\n      ['enter', content, context],\n      ['enter', text, context],\n      ['exit', text, context],\n      ['exit', content, context]\n    ])\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  let size = 0\n  return start\n\n  /**\n   * Start of a heading (atx).\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    effects.enter('atxHeading')\n    return before(code)\n  }\n\n  /**\n   * After optional whitespace, at `#`.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter('atxHeadingSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening sequence.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code)\n      return sequenceOpen\n    }\n\n    // Always at least one `#`.\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingSequence')\n      return atBreak(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * After something, before something else.\n   *\n   * ```markdown\n   * > | ## aa\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence')\n      return sequenceFurther(code)\n    }\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('atxHeading')\n      // To do: interrupt like `markdown-rs`.\n      // // Feel free to interrupt.\n      // tokenizer.interrupt = false\n      return ok(code)\n    }\n    if (markdownSpace(code)) {\n      return factorySpace(effects, atBreak, 'whitespace')(code)\n    }\n\n    // To do: generate `data` tokens, add the `text` token later.\n    // Needs edit map, see: `markdown.rs`.\n    effects.enter('atxHeadingText')\n    return data(code)\n  }\n\n  /**\n   * In further sequence (after whitespace).\n   *\n   * Could be normal “visible” hashes in the heading or a final sequence.\n   *\n   * ```markdown\n   * > | ## aa ##\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceFurther(code) {\n    if (code === 35) {\n      effects.consume(code)\n      return sequenceFurther\n    }\n    effects.exit('atxHeadingSequence')\n    return atBreak(code)\n  }\n\n  /**\n   * In text.\n   *\n   * ```markdown\n   * > | ## aa\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function data(code) {\n    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingText')\n      return atBreak(code)\n    }\n    effects.consume(code)\n    return data\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}